#!/usr/bin/env python
#
#    reverseproxy-relation-changed - hook for when reverse proxy relation changes
#
#    Copyright (C) 2011  Canonical Ltd.
#    Author: Clint Byrum <clint.byrum@canonical.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import sys
import os
import subprocess
import json
import tempfile
import glob

from socket import getaddrinfo

remote_unit = os.environ.get("JUJU_REMOTE_UNIT")

service_name, _ = remote_unit.split("/")

# TODO: maybe load this from disk for easier customization
t1 = """
# Generated by juju
proxy_cache_path /mnt/ramdisk/proxy-cache levels=1:2 keys_zone=microcache:5m max_size=1000m;

"""
# servers will go here
template = """
server {
  listen 80 default;
  server_name www.omgubuntu.co.uk omgubuntu.co.uk _;

  location / {
    set $no_cache "";

    if ($request_method !~ ^(GET|HEAD)$) {
      set $no_cache "1";
    }

    if ($no_cache = "1") {
      add_header Set-Cookie "_mcnc=1; Max-Age=2; Path=/";
      add_header X-Microcachable "0";
    }

    if ($http_cookie ~* "_mcnc") {
      set $no_cache "1";
    }

    proxy_no_cache $no_cache;
    proxy_cache_bypass $no_cache;

    proxy_redirect   http://backend  /;
    proxy_pass  http://backend;
    proxy_cache microcache;
    proxy_cache_key $scheme$host$request_method$request_uri;
    proxy_cache_valid 200 30s;
    proxy_cache_use_stale updating;

    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

    proxy_max_temp_file_size 1M;

    # Custom logging
    log_format custom '$remote_addr - $remote_user [$time_local]  '
             '"$request" $status $body_bytes_sent '
             '"$http_referer" "$http_user_agent" nocache:$no_cache';
    access_log  /mnt/logs/microcache.log custom;
  }
}
"""

units = []
p = subprocess.Popen("relation-list", stdout=subprocess.PIPE)
for unit in p.stdout:
    units.append(unit.strip())

print units

servers = """
upstream backend {
  server 127.0.0.1:8080;
"""
for unit in units:
    p = subprocess.Popen(["relation-get", "private-address", unit],
                         stdout=subprocess.PIPE, close_fds=True)
    paddress = p.stdout.read().strip()
    p.wait()
    # Add all configured units:
    servers += ("  server %s:8080;\n" % (paddress))
servers += '}'

print servers

with tempfile.NamedTemporaryFile(dir="/etc/nginx/sites-available/",prefix="loadbalancer", delete=False) as conf:
    conf.write(t1 + servers + template)
    try:
        os.unlink("/etc/nginx/sites-available/loadbalancer.old")
    except:
        pass
    try:
        os.rename("/etc/nginx/sites-available/loadbalancer","/etc/nginx/sites-available/loadbalancer.old")
    except:
        pass
    try:
      os.rename(conf.name, "/etc/nginx/sites-available/loadbalancer")
    except:
        os.unlink(conf.name)


template_adm = """
server {
  listen 80;
  server_name admin.omgubuntu.co.uk admin-staging.omgubuntu.co.uk;
  location / {
    set $no_cache "";

    if ($request_method !~ ^(GET|HEAD)$) {
      set $no_cache "1";
    }

    if ($no_cache = "1") {
      add_header Set-Cookie "_mcnc=1; Max-Age=2; Path=/";
      add_header X-Microcachable "0";
    }

    if ($http_cookie ~* "_mcnc") {
      set $no_cache "1";
    }

    proxy_no_cache $no_cache;
    proxy_cache_bypass $no_cache;

    proxy_redirect   http://admin  /;
    proxy_pass  http://admin;
    proxy_cache microcache;
    proxy_cache_key $scheme$host$request_method$request_uri;
    proxy_cache_valid 200 30s;
    proxy_cache_use_stale updating;

    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

    proxy_max_temp_file_size 1M;

    # Custom logging
    log_format custom '$remote_addr - $remote_user [$time_local]  '
             '"$request" $status $body_bytes_sent '
             '"$http_referer" "$http_user_agent" nocache:$no_cache';
    access_log  /mnt/logs/microcache.log custom;
  }
}
"""

admin = """
upstream admin {
  ip_hash;
  server 127.0.0.1:8080;
"""
for unit in units:
    p = subprocess.Popen(["relation-get", "private-address", unit],
                         stdout=subprocess.PIPE, close_fds=True)
    paddress = p.stdout.read().strip()
    p.wait()
    # Add all configured units:
    admin += ("  server %s:8080;\n" % (paddress))
admin += '}'

print admin

with tempfile.NamedTemporaryFile(dir="/etc/nginx/sites-available/",prefix="admin", delete=False) as conf:
    conf.write(t1 + admin + template_adm)
    try:
        os.unlink("/etc/nginx/sites-available/admin.old")
    except:
        pass
    try:
        os.rename("/etc/nginx/sites-available/admin","/etc/nginx/sites-available/admin.old")
    except:
        pass
    try:
      os.rename(conf.name, "/etc/nginx/sites-available/admin")
    except:
        os.unlink(conf.name)


# Just in case haproxy wouldn't start because of empty/bad configs before, start it now
subprocess.call(["service", "nginx", "start"])
subprocess.check_call(["service", "nginx", "reload"])

subprocess.check_call(["open-port", "80"])
